# 简历

[TOC]

## 自我介绍

介绍顺序：学校。京东实习：部门（互联网医疗， 小组（基础服务：主数据、预约系统、结算系统、权限系统等），预约系统（功能：排班、订单），介绍自己的工作，亮点：redis（缓存、分布式锁，幂等），mysql（优化慢sql）。网易实习：部门，项目（体育模块：足球篮球比赛信息后台接口，技术点：springCache-redis。热门股票筛选（guavaCache多线程更新本地缓存））。

## 部门、小组

我们部门是互联网医疗研发部。我们组主要负责基础服务这块，包括

- 主数据，主要包括医生信息和医院、科室信息。权益系统，主要处理权益相关逻辑，以及商家的金额相关处理。
- 结算系统，主要处理医生线上问诊的收入结算相关。
- 随访系统，主要处理维护医生给患者定制的一系列的随访计划以及一些量表相关权益的处理。
- 预约系统，主要是处理医生的排班信息。电话问诊、视频问诊需要提前排班，患者需要选择时段，就跟看电影的时候需要选择电影票时间的逻辑差不多
- 商品推荐系统。
- 权益系统
- 评价系统，主要处理医生的评价。京东自建的互联网医院系统
- 任务系统：运营可以给医生建立一堆任务，促使医生去完成这些任务，可以使医生得到一些奖励，从而使医生在平台比较活跃，激励他去做一些提升服务质量的行为。

## 预约系统

### 系统功能流程介绍

原则：业务无关性、基于规则配置

功能：

排班模版：新增、修改、查询、针对时间段停诊（返回冲突的订单）、取消停诊。

下预约单：下预约单（生成排班计划）、修改预约时间。注意：下预约单不涉及支付确认等逻辑，这里要求下单前，先生成业务内自己的订单id，我们根据业务系统的订单id，为其生成预约单。预约系统只涉及时间段和排班。

排班计划：查询

优化前：创建排版模版和生成排版计划耦合在一起，创建时即生成排版计划，医生再设置停诊时间段或因为其他原因导致的设置不可预约时间段，都要直接修改排版计划。

优化后，排版模版和排版计划分开，前台只展示 可预约的排版模版（已排除停诊、已预约等不可预约的时间段），患者选中时间段下单后才生成排版计划。

总结：排版计划何时生成的问题，优化后更灵活。

### 简历内容

```
电话问诊优化 – 预约系统 

• 项目背景：针对电话问诊目前存在问诊时长单一，预约时长跨度单一，医生发起问诊时间不够灵活等问题进行定向改造。

• 项目简述：根据需求编写以下接口：

①   医生设置、查询预约模版接口。设置包括新增和更新医生排班模版。

②   患者查询预约模版接口。将医生设置的大段时间按小时进行切分，与不可预约（已被预约、停诊等）时间比较，只展示给用户可预约时间段。

③   预约下单接口、修改预约单接口。给业务订单分配排班计划，生成一个完整的预约单。

④   医生提前通话完成，需释放该时间段。作为消费者监听生产者发送的消费成功消息，修改该时段为可预约。

• 主要工作：①更新预约模版和预约单时，利用分布式锁把更新缓存和数据库操作封装为逻辑上的一个操作保证缓存数据库的一致性。

②修改预约单接口时，使用 Redis 做幂等处理，保证对同一个业务订单 id 修改成功后不会被再次修改。

③优化慢 SQL。
```

### 主要工作

1. 创建预约时间模版：获取分布式锁；事务落库。
2. 更新预约模版：删数据库，重新设置；删除可预约时间段缓存。（采用先更新数据库、再删缓存的策略，为什么采取这种策略？）
3. 下预约单：幂等处理，查询缓存的结果，有结果的直接返回（修改预约时间的时候，redis里只放成功后的id：对参数中的业务订单id修改成功的，使用redis缓存起来，）。下预约单时，使用分布式锁锁定资源，事务落库，删除当天排班计划缓存。

4. 优化慢 SQL。分页查询优化；消除关联查询

5. 消息丢失：在生产者发送mq消息之前，先把该条消息写入消息发送表，初始状态是待处理，然后再发送mq消息。消费者消费消息时，处理完业务逻辑之后，再回调生产者的一个接口，修改消息状态为已处理。

   如果生产者把消息写入消息发送表之后，再发送mq消息到mq服务端的过程中失败了，造成了消息丢失。

   这时候，要如何处理呢？

   答：使用job，增加重试机制。

   使用job每隔一段时间去查询消息发送表中状态为待处理的数据，然后重新发送mq消息。

6. 重复消费：使用redis只缓存操作成功后的订单ID，先判断redis里有无再进行操作

## 网易新闻体育频道

### 简历内容

```
体育频道 - 足球和篮球赛事数据相关接口
•	项目背景：项目时间过久，代码逻辑混乱，难以维护，借更换数据商的机会重构相关接口。
•	项目简述：调用数据商提供的数据接口获取相关数据，编写赛程、积分、球队/球员榜、技术统计等相关接口。
•	主要工作：
①使用 Spring Cache 集成 Redis 缓存数据；
②针对球员位置的大量 if/else 逻辑判断，通过策略模式重构，提高可维护性和可读性。
•	最终效果：均已上线，并正常使用。日常访问量平均20w/日，峰值80w/日。
•	访问地址：
足球：http://goal.sports.163.com/footballpc/index.html#/index  
篮球：https://nba.sports.163.com/basketballpc/index.html#/schedule
财经频道 - 热门股票展示
•	项目简述：调用主站相关数据接口获取股票的交易信息，筛选出用户未关注的热门的前 6 支股票展示给用户。
•	主要工作：采取的策略是使用 Guava Cache 将市值排名前 300 的股票先缓存到本地缓存中，使用线程池异步刷新缓存值。
•	最终效果：已上线并正常使用。
```

### 主要工作

1. springCache - redis 原理：AOP

2. 策略模式：

3. guava cache 线程池异步刷新：

   // 设置缓存在写入10分钟后，通过CacheLoader的load方法进行刷新

   定时刷新：更新线程调用load方法更新该缓存，其他请求线程返回该缓存的旧值。这样对于某个key的缓存来说，只会有一个线程被阻塞，用来生成缓存值，而其他的线程都返回旧的缓存值，不会被阻塞。

   **当key过期时，有新用户线程读取cache时，开启一个新线程去生成缓存，用户线程直接返回老的值**

   当缓存的key很多时，高并发条件下大量线程同时获取不同key对应的缓存，此时依然会造成大量线程阻塞，并且给数据库带来很大压力。这个问题的解决办法就是将刷新缓存值的任务交给后台线程，所有的用户请求线程均返回旧的缓存值，这样就不会有用户线程被阻塞了。

   新建了一个线程池，用来执行缓存刷新任务。并且重写了CacheLoader的**reload**方法，在该方法中建立缓存刷新的任务并提交到线程池。
   注意此时缓存的刷新依然需要靠用户线程来驱动，该用户线程触发刷新操作之后，会立马返回旧的缓存值。

   - 可以看到防缓存击穿和防用户线程阻塞都是依靠返回旧值来完成的。所以如果没有旧值，同样会全部阻塞，因此应视情况尽量在系统启动时将缓存内容加载到内存中。